% %{ coordinates

def coordinates {

	def size 1

	line[arrows=->] (0, 0, 0)(size, 0, 0)

	special |\scriptsize
		\uput{2pt}[ul]#1{$\mathbf{x}$}|
		(size, 0, 0)

	line[arrows=->] (0, 0, 0)(0, size, 0)

	special |\scriptsize
		\uput{2pt}[ul]#1{$\mathbf{y}$}|
		(0, size, 0)

	line[arrows=->] (0, 0, 0)(0, 0, size)

	special |\scriptsize
		\uput{2pt}[ul]#1{$\mathbf{z}$}|
		(0, 0, size)
}

% %}

% %{ scatterer

def scatterer {

	def size 0.1

	def p1 (size,size,0)
  def p2 (size,-size,0)
  def p3 (-size,-size,0)
  def p4 (-size,size,0)

  polygon[fillcolor=black](p1)(p2)(p3)(p4)
  polygon[fillcolor=black](p4)(p3)(p2)(p1)
}

% %}

% %{ impact_cross_section

def impact_cross_section {

	def size 0.05

	def p1 (size,size,0)
  def p2 (size,-size,0)
  def p3 (-size,-size,0)
  def p4 (-size,size,0)

  polygon[fillcolor=green,linecolor=green](p1)(p2)(p3)(p4)
  polygon[fillcolor=green,linecolor=green](p4)(p3)(p2)(p1)

  special |\tiny
    \uput{2pt}[ul]#1{$\mathbf{d\sigma}$}|
    (p1)
}

% %}

def sphere_radius 1.00
def init_angle 60

% %{ sphere

def sphere {

  def n_segs 64
  def ang_step 360/n_segs
  def cos_step cos(ang_step)*sphere_radius
  def sin_step sin(ang_step)*sphere_radius

  repeat { n_segs, rotate(360 / n_segs, (0,0,0), [0,1,0]) } line[linecolor=lightgray, linewidth=1pt] (sphere_radius,0,0)(cos_step,0,sin_step)
  repeat { n_segs, rotate(360 / n_segs, (0,0,0), [0,0,1]) } line[linecolor=lightgray] (sphere_radius,0,0)(cos_step,sin_step,0)
  repeat { n_segs, rotate(ang_step, (0,0,0), [1,0,0]) } line[linecolor=lightgray] (0,sphere_radius,0)(0,cos_step,sin_step)
}

% %}

  % %{ belt_segment
  
  def belt_segment {
  
    def length 4
    def n_segs 3
    def ang_step length/n_segs
  
    def init_point (sphere_radius*cos(90-init_angle-length/2), 0, -sphere_radius*sin(90-init_angle-length/2))
    def init_point2 (sphere_radius*cos(90-init_angle-length/2+ang_step), 0, -sphere_radius*sin(90-init_angle-length/2+ang_step))
  
    repeat { n_segs, rotate(ang_step, (0,0,0), [0,1,0]) } line[linecolor=blue,linewidth=1pt] (init_point)(init_point2)
  }
  
  % %}

  % %{ theta_arrow
  
  def theta_arrow {
  
    def n_segs 16
    def ang_step (init_angle-4)/n_segs
    def radius_factor 0.5
  
    def init_point (0, 0, -radius_factor*sphere_radius)
    def init_point2 (0, radius_factor*sin(ang_step)*sphere_radius, -radius_factor*sphere_radius*cos(ang_step))
  
    repeat { n_segs, rotate(ang_step, (0,0,0), [1,0,0]) } line[linecolor=black,linewidth=1pt] (init_point)(init_point2)
  
    put { rotate(init_angle-5, (0,0,0), [1,0,0]) } line[linecolor=black,linewidth=1pt,arrows=->] (init_point)(init_point2)
  
    line[linecolor=lightgray,linestyle=dashed,linewidth=0.5pt](0, 0, 0)(0, sin(init_angle)*1, -cos(init_angle)*1)

    put { rotate((init_angle-10)/2, (0,0,0), [1,0,0]) then translate([0,0.05,-0.15]) } special |\tiny
      \uput{2pt}[ul]#1{$\mathbf{\theta}$}|
      (0, 0, -sphere_radius/2)
  }
  
  % %}

  % %{ phi_arrow
  
  def phi_arrow {
  
    def n_segs 16
    def ang_step -70/n_segs
    def radius (sin(init_angle)*sphere_radius)*1.2
  
    def init_point (-radius, 0, -cos(init_angle)*sphere_radius*1.1)
    def init_point2 (-cos(ang_step)*radius, sin(-ang_step)*sphere_radius*1.1, -cos(init_angle)*sphere_radius*1.1)
  
    repeat { n_segs, rotate(ang_step, (0,0,-cos(init_angle)*sphere_radius), [0,0,1]) } line[linecolor=black,linewidth=1pt] (init_point)(init_point2)
  
    put { rotate(-70, (0,0,-cos(init_angle)*sphere_radius), [0,0,1]) } line[linecolor=black,linewidth=1pt,arrows=->] (init_point)(init_point2)
  
    line[linecolor=lightgray,linestyle=dashed,linewidth=0.5pt](0, 0, 0)(0, sin(init_angle)*1, -cos(init_angle)*1)
    line[linecolor=lightgray,linestyle=dashed,linewidth=0.5pt](0, 0, 0)(0, 0, -sphere_radius)

    put { rotate(-70/2, (0,0,-cos(init_angle)*sphere_radius), [0,0,1]) then translate([0,0.05,-0.15]) } special |\tiny
      \uput{2pt}[ul]#1{$\mathbf{\phi}$}|
      (init_point)
  }
  
  % %}

  % %{ deflection_curve
  
  def deflection_curve {
  
    def x_z 0.5*sphere_radius
    def x_y 0
  
    def y_z -cos(init_angle)*sphere_radius/2
    def y_y sin(init_angle)*sphere_radius/2
  
    def mid_z (x_z + y_z)/2
    def mid_y (x_y + y_y)/2
  
    def vec_norm_z mid_z-x_z
    def vec_norm_y mid_y-x_y
  
    def vec_z vec_norm_y/|[vec_norm_z,vec_norm_y]|
    def vec_y -vec_norm_z/|[vec_norm_z,vec_norm_y]|
  
    def len sqrt((x_z - y_z)*(x_z - y_z) + (x_y - y_y)*(x_y - y_y))
  
    def alpha 180-init_angle
    def beta alpha/2
  
    def v (len/2)*(sin(beta)/cos(beta))
  
    def center_z mid_z + v*vec_z
    def center_y mid_y + v*vec_y
  
    def radius sqrt((center_z - x_z)*(center_z - x_z) + (center_y - x_y)*(center_y - x_y))
  
    % line[linecolor=black](0, mid_y, mid_z)(0, center_y, center_z)
    % line[linecolor=black](0, x_y, x_z)(0, y_y, y_z)
  
    def n_segs 64
    def ang_step (180-alpha)/n_segs
    def cos_step cos(ang_step)
    def sin_step sin(ang_step)
  
    def start_x -x_z
    def x_x -x_z
    def center_x -center_z
    def start_z x_z
    def start_y x_y
  
    def second_x center_x + ((x_x - center_x)*cos_step - (x_y - center_y)*sin_step)
    def second_y center_y + ((x_x - center_x)*sin_step + (x_y - center_y)*cos_step)
    def second_z -second_x
  
    repeat { n_segs, rotate(ang_step, (0, center_y, center_z), [1,0,0]) } line[linecolor=red, linewidth=1pt] (0,start_y,start_z)(0,second_y,second_z)
  }
  
  % %}

% %{ belt

def belt {

  def offset 0.5

  line[linecolor=red,arrows=>-](0,0,2)(0,0,0.5)
  line[linecolor=red,arrows=->](0,sin(init_angle)*sphere_radius/2,-cos(init_angle)*sphere_radius/2)(0,sin(init_angle)*(sphere_radius+offset),-cos(init_angle)*(sphere_radius+offset))
  line[linecolor=lightgray,linestyle=dashed,linewidth=0.5pt](0, 0, 0)(0, 0, sphere_radius/2)

  def n_segs 360
  def ang_step 360/n_segs

  repeat { n_segs, rotate(ang_step, (0,0,0), [0,0,1]) } {belt_segment} 

  {theta_arrow}
  {phi_arrow}

  {deflection_curve}

  def omega_point (sphere_radius*cos(90-init_angle), 0, -sphere_radius*sin(90-init_angle))

  put { translate([0.1,-0.2,-0.05]) } special |\scriptsize
    \uput{2pt}[ul]#1{$\mathbf{d\Omega}$}|
    (omega_point)
}

% %}

def scene {

  def scatterer_distance 5
  def scatterer_position [0,0,-scatterer_distance]
  def impact_cross_section_position [0,0,-scatterer_distance+sphere_radius]
  def radiation_source (0,0,-2)

  % {coordinates}

  put { translate([scatterer_position]) } {sphere}
  put { translate([scatterer_position]) } {scatterer}
  put { translate([impact_cross_section_position]) } {impact_cross_section}
  put { translate([scatterer_position]) } {belt}

  % curve [linecolor=black] (0,0,0)(1,1,-1)(2,3,-4)
}

def eye (10,3,-10)
def look_at (0,0,0)
put { view((eye), (look_at)) then perspective(20) } {scene}
