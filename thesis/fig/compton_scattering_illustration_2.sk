def scatterer_distance 5
def source_distance 2

def sphere_radius 1.00
def init_angle 120
def impact_parameter 0.15
def scatterer_position [0,0,-scatterer_distance]
def impact_cross_section_position [0,0,-scatterer_distance+sphere_radius+0.5]
def radiation_source (0,0,-source_distance)

% %{ coordinates

def coordinates {

	def size 1

	line[arrows=->] (0, 0, 0)(size, 0, 0)

	special |\scriptsize
		\uput{2pt}[ul]#1{$\mathbf{x}$}|
		(size, 0, 0)

	line[arrows=->] (0, 0, 0)(0, size, 0)

	special |\scriptsize
		\uput{2pt}[ul]#1{$\mathbf{y}$}|
		(0, size, 0)

	line[arrows=->] (0, 0, 0)(0, 0, size)

	special |\scriptsize
		\uput{2pt}[ul]#1{$\mathbf{z}$}|
		(0, 0, size)
}

% %}

% %{ scatterer

def scatterer {

	def size 0.1

	def p1 (size,size,0)
  def p2 (size,-size,0)
  def p3 (-size,-size,0)
  def p4 (-size,size,0)

  polygon[fillcolor=black](p1)(p2)(p3)(p4)
  polygon[fillcolor=black](p4)(p3)(p2)(p1)
}

% %}

% %{ impact_cross_section

def impact_cross_section {

  def inner_radius 0.1
  def outer_radius 0.2

  % %{ impact_parameter_arrows

  def impact_parameter_arrows {

    def a (0,0,0)
    def b (0,inner_radius,0)

    line [linecolor=black,arrows=->] (a)(b)

    put { translate([0,-0.15,-0.08]) } { special |\tiny
      \uput{2pt}[ul]#1{$\mathbf{b}$}|
      (a) }

    line [linecolor=lightgray] (0,inner_radius,0.5)(0,inner_radius,-0.2)
  }

  % %}

  def n_segs 16
  def ang_step 360/n_segs

  sweep [fillcolor=green,linecolor=green] { n_segs, rotate(ang_step, (0,0,0), [0,0,1]) } line[linecolor=green] (0,inner_radius,0) (0,outer_radius,0)

  special |\tiny
    \uput{2pt}[ul]#1{$\mathbf{d\sigma}$}|
    (outer_radius+0.00, -0.1, 0)

  put { translate([0,0,-0.2]) } {impact_parameter_arrows}
}

% %}

% %{ sphere

def sphere {

  def n_segs 64
  def ang_step 360/n_segs

  sweep [linecolor=lightgray] { n_segs, rotate(360 / n_segs, (0,0,0), [0,1,0]) } (sphere_radius,0,0)
  sweep [linecolor=lightgray] { n_segs, rotate(360 / n_segs, (0,0,0), [0,0,1]) } (sphere_radius,0,0)
  sweep [linecolor=lightgray] { n_segs, rotate(ang_step, (0,0,0), [1,0,0]) } (0,sphere_radius,0)
}

% %}

  % %{ theta_arrow
  
  def theta_arrow {
  
    def n_segs 16
    def ang_step (init_angle-4)/n_segs
    def radius_factor 0.5
  
    def init_point (0, 0, -radius_factor*sphere_radius)
    def init_point2 (0, radius_factor*sin(ang_step)*sphere_radius, -radius_factor*sphere_radius*cos(ang_step))
  
    sweep [linecolor=black] { n_segs, rotate(ang_step, (0,0,0), [1,0,0]) } (init_point)
  
    put { rotate(init_angle-5, (0,0,0), [1,0,0]) } line[linecolor=black,linewidth=1pt,arrows=->] (init_point)(init_point2)
  
    line[linecolor=lightgray,linestyle=dashed,linewidth=0.5pt](0, 0, 0)(0, sin(init_angle)*(sphere_radius/2 + 0*impact_parameter), -cos(init_angle)*(sphere_radius/2 + 0*impact_parameter))

    put { rotate((init_angle-10)/2, (0,0,0), [1,0,0]) then translate([0,0.05,-0.15]) } special |\tiny
      \uput{2pt}[ul]#1{$\mathbf{\theta}$}|
      (0, 0, -sphere_radius/2)
  }
  
  % %}

  % %{ phi_arrow
  
  def phi_arrow {
  
    def n_segs 16
    def ang_step -70/n_segs
    def radius (sin(init_angle)*sphere_radius)*1.2
  
    def init_point (-radius, 0, -cos(init_angle)*sphere_radius*1.1)
    def init_point2 (-cos(ang_step)*radius, sin(-ang_step)*sphere_radius*1.1, -cos(init_angle)*sphere_radius*1.1)
  
    sweep [linecolor=black] { n_segs, rotate(ang_step, (0,0,-cos(init_angle)*sphere_radius), [0,0,1]) } (init_point)
  
    put { rotate(-70, (0,0,-cos(init_angle)*sphere_radius), [0,0,1]) } line[linecolor=black,linewidth=1pt,arrows=->] (init_point)(init_point2)

    put { rotate(-70/2, (0,0,-cos(init_angle)*sphere_radius), [0,0,1]) then translate([0,0.05,-0.15]) } special |\tiny
      \uput{2pt}[ul]#1{$\mathbf{\phi}$}|
      (init_point)
  }
  
  % %}

  % %{ deflection_curve
  
  def deflection_curve {
  
    def x_z 0.5*sphere_radius
    def x_y impact_parameter
  
    def y_z -cos(init_angle)*(sphere_radius/2 + impact_parameter)
    def y_y sin(init_angle)*(sphere_radius/2 + impact_parameter)
  
    def mid_z (x_z + y_z)/2
    def mid_y (x_y + y_y)/2
  
    def vec_norm_z mid_z-x_z
    def vec_norm_y mid_y-x_y
  
    def vec_z vec_norm_y/|[vec_norm_z,vec_norm_y]|
    def vec_y -vec_norm_z/|[vec_norm_z,vec_norm_y]|
  
    def len sqrt((x_z - y_z)*(x_z - y_z) + (x_y - y_y)*(x_y - y_y))
  
    def alpha 180-init_angle
    def beta alpha/2
  
    def v (len/2)*(sin(beta)/cos(beta))
  
    def center_z mid_z + v*vec_z
    def center_y mid_y + v*vec_y
  
    def radius sqrt((center_z - x_z)*(center_z - x_z) + (center_y - x_y)*(center_y - x_y))
  
    % line[linecolor=black](0, mid_y, mid_z)(0, center_y, center_z)
    % line[linecolor=black](0, x_y, x_z)(0, y_y, y_z)
  
    def n_segs 64
    def ang_step (180-alpha)/n_segs
    def cos_step cos(ang_step)
    def sin_step sin(ang_step)
  
    def start_x -x_z
    def x_x -x_z
    def center_x -center_z
    def start_z x_z
    def start_y x_y
  
    sweep [linecolor=red] { n_segs, rotate(ang_step, (0, center_y, center_z), [1,0,0]) } (0,start_y,start_z)
  }
  
  % %}

  % %{ belt_segment
  
  def belt_segment {
  
    def length 5
    def n_segs 3
    def ang_step length/n_segs
  
    def init_point (sphere_radius*cos(90-init_angle-length/2), 0, -sphere_radius*sin(90-init_angle-length/2))
  
    sweep [linecolor=blue, fillcolor=blue] { n_segs<>, rotate(ang_step, (0,0,0), [0,1,0]) } (init_point)
  }
  
  % %}

% %{ belt

def belt {

  def n_segs 360
  def ang_step 360/n_segs

  sweep [fillcolor=blue,linecolor=blue] { n_segs<>, rotate(ang_step, (0,0,0), [0,0,1]) } {belt_segment} 

  {theta_arrow}
  {phi_arrow}

  {deflection_curve}

  def omega_point (sphere_radius*cos(90-init_angle), 0, -sphere_radius*sin(90-init_angle))

  put { translate([0.2,-0.2,-0.05]) } special |\scriptsize
    \uput{2pt}[ul]#1{$\mathbf{d\Omega}$}|
    (omega_point)
}

% %}

% %{ incoming_ray

def incoming_ray {

  line[linecolor=red,arrows=>-](0,impact_parameter,source_distance)(0,impact_parameter,0.5)

  line[linecolor=lightgray,linestyle=dashed,linewidth=0.5pt](0,0,source_distance)(0,0,-1)
}

% %}

% %{ outcoming_ray

def outcoming_ray {

  def offset 0.35

  line[linecolor=red,arrows=->](0,sin(init_angle)*(sphere_radius/2 + impact_parameter),-cos(init_angle)*(sphere_radius/2 + impact_parameter))(0,sin(init_angle)*(sphere_radius+offset),-cos(init_angle)*(sphere_radius+offset))
}

% %}

def scene {

  % {coordinates}

  put { translate([impact_cross_section_position]) } {impact_cross_section}
  put { translate([scatterer_position]) } {incoming_ray}
  put { translate([scatterer_position]) } {outcoming_ray}
  put { translate([scatterer_position]) } {sphere}
  put { translate([scatterer_position]) } {scatterer}
  put { translate([scatterer_position]) } {belt}

  % curve [linecolor=black] (0,0,0)(1,1,-1)(2,3,-4)
}

def eye (10,3,-10)
def look_at (0,0,0)

% def eye (0.5,0,0)
% def look_at (0,0,-10)

put { view((eye), (look_at)) then perspective(20) } {scene}
